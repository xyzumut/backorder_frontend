<?php

namespace App\Controller;

use App\Entity\Domains;
use App\Messages\Worker1Message;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Messenger\MessageBusInterface;

class DomainController extends AbstractController {
    private $entityManager;
    private $messageBus;
    public function __construct( MessageBusInterface $messageBus, EntityManagerInterface $entityManager ) {
        $this->entityManager    = $entityManager;
        $this->messageBus       = $messageBus;
    }

    /**
     * @param Request $request
     * @return JsonResponse
     * @throws \Doctrine\ORM\NonUniqueResultException
     * search aranacak string, page ve pagePerSize sayfalama ile alakalı integer değişkenler
     * filter 1-15 arası select filtre integer değişkeni,
     * orderBy ASC|DESC stringi
     * sortBy sıralanacak sütun ismi olan string, opsiyonlar : id|domain|status|approved TODO: buraya dropdate eklenecek
     */
    public function getDomainsWithInformations( Request $request ){

        $domainRepository   = $this->entityManager->getRepository( Domains::class );
        $query              = $domainRepository->createQueryBuilder( 'domains' )->select( 'COUNT(domains.id)' )->getQuery();
        $total_data         = $query->getSingleScalarResult();

        $page           = json_decode( $request->query->get( 'page' ) );// int
        $pagePerSize    = json_decode( $request->query->get( 'pagePerSize' ) );// int
        $filter         = json_decode( $request->query->get( 'filter' ) );// int
        $search         = $request->query->get( 'search' );//string
        $orderBy        = $request->query->get( 'orderBy' );// string ASC DESC
        $sortBy         = $request->query->get( 'sortBy' );// string sütun ismi
        $startDate      = $request->query->get( 'startDate' );
        $endDate        = $request->query->get( 'endDate' );

        if ( is_null( $orderBy ) ) {// bunlar eklendi
            $orderBy = 'ASC';
        }
        if ( is_null( $page ) || $page < 0 ) {// bunlar eklendi
            $page = 1;
        }
        if ( is_null( $pagePerSize ) || $pagePerSize < 0 ) {// bunlar eklendi
            $pagePerSize = 10;
        }
        if ( is_null( $filter ) ) {//bunlar eklendi
            $filter = 0;
        }
        if ( is_null( $search ) ) {// bunlar eklendi
            $search = '';
        }
        if ( is_null( $sortBy ) ) {// bunlar eklendi
            $sortBy = 'id';
        }

        $qb = $this->entityManager->createQueryBuilder();
        $filterQuery = $this->addFilter( [ $qb->expr()->like('LOWER(domains.domain)', ':searchTermLower') ], $filter, $qb );

        if ( ! ( empty( $startDate ) || empty( $endDate ) ) ){
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->between('domains.drop_date', ':startDate', ':endDate') ] );
        }

        $qb ->select('domains') ->from('App\Entity\Domains', 'domains')
            ->where( ...$filterQuery )
            ->orderBy('domains.'.$sortBy, $orderBy)
            ->setParameter('searchTermLower', '%'.strtolower( $search ).'%');

        if ( (!empty( $startDate )) && !empty( $endDate ) ){
            $qb->setParameter( 'startDate', $startDate )->setParameter( 'endDate', $endDate );
        }

        $filteredCount = count( $qb->getQuery()->getResult() );

        $qb ->setFirstResult(( $page - 1 ) *  $pagePerSize )
            ->setMaxResults( $pagePerSize );

        $domainsObject = $qb->getQuery()->getResult();
        $domains = [];

        foreach ( $domainsObject as $object ){
            $infos = [];
            foreach ( $object->getInfo() as $infoObject ){
                $infoTemp = [
                    'id' => $infoObject->getId(),
                    'source' => $infoObject->getInformationSource(),
                    'info' => $infoObject->getInformation(),
                    'type' => $infoObject->getType()
                ];
                $infos[] = $infoTemp;
            }
            $temp = [
                'key'           => $object->getId(),
                'domain'        => $object->getDomain(),
                'dropDate'      => $object->getDropDate()->format( 'Y-m-d' ),
                'status'        => $object->isStatus(),
                'approved'      => $object->isApproved(),
                'infosCount'    => count( $infos ),
                'infos'         => $infos,
            ];
            $domains[] = $temp;
        }

        $meta = [
            'page'              => $page,
            'pagePerSize'       => $pagePerSize,
            'filteredDataCount' => $filteredCount,
            'totalData'         => $total_data
        ];

        return new JsonResponse( [ 'status' => true, 'meta' => $meta, 'data' => $domains, 'message' => null ], 200 );
    }

    /**
     * @param $filterQuery
     * @param $filter
     * @param $qb
     * @return array|mixed
     * seçimli filtreleri uygulayan fonksiyonum
     */
    private function addFilter( $filterQuery, $filter, $qb ){
        // 1 onaylananlar, 2 onaylanmayanlar, 4 kuyruktakiler, 8 kontrol edilenler
        if ( $filter === 1 || $filter === 13 ) {
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.approved', true ) ] );
        }
        else if( $filter === 2 || $filter === 14 ) {
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.approved', 0 ) ] );
        }
        else if( $filter === 4 || $filter === 7 ){
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.status', 0 ) ] );
        }
        else if( $filter === 8 || $filter === 11 ){
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.status', true ) ] );
        }
        else if( $filter === 5 ){
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.status', 0 ), $qb->expr()->eq( 'domains.approved', true ) ] );
        }
        else if( $filter === 6 ){
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.status', 0 ), $qb->expr()->eq( 'domains.approved', 0 ) ] );
        }
        else if( $filter === 9 ){
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.status', true ), $qb->expr()->eq( 'domains.approved', true ) ] );
        }
        else if( $filter === 10 ){
            $filterQuery = array_merge( $filterQuery, [ $qb->expr()->eq( 'domains.status', true ), $qb->expr()->eq( 'domains.approved', 0 ) ] );
        }
        return $filterQuery;
    }

    /**
     * @param Request $request
     * @return JsonResponse
     * payload üzerinden dropDate domain alır.
     */
    public function add( Request $request ){

        $payload = json_decode( $request->getContent() );

        $dropDate  = isset( $payload->dropDate ) ? $payload->dropDate : null;
        $domain    = isset( $payload->domain )    ? $payload->domain   : null;

        $drop_date_immutable = \DateTimeImmutable::createFromFormat( 'Y-m-d', $dropDate );

        $domainObject = new Domains();
        $domainObject->setDomain( $domain );
        $domainObject->setDropDate($drop_date_immutable);
        $domainObject->setStatus( false );
        $domainObject->setApproved( false );
        try {
            $this->entityManager->persist( $domainObject );
            $this->entityManager->flush();
        }
        catch ( \Exception $error ){
             return new JsonResponse( [ 'status' => false, 'meta'=> null, 'data' => null, 'message' => $error->getMessage() ], 401 );
        }

        $message = new Worker1Message( [ 'domain' => $domain, 'drop_date' => $dropDate ] );
        $this->messageBus->dispatch( $message );

        return new JsonResponse( [ 'status' => true, 'meta' => null , 'data' => null, 'message' => null ] , 200 );

    }

    /**
     * @param int $id
     * @return JsonResponse
     */
    public function delete( int $id ){

        $domain = $this->entityManager->getRepository( Domains::class )->find( $id );
        if ( ! $domain ) {
            return new JsonResponse( [ 'status' => false, 'meta' => null, 'data' => null, 'message' => $id.' numaralı domain bulunamadı' ] , 404 );
        }

        $this->entityManager->remove( $domain );
        $this->entityManager->flush();
        return new JsonResponse( [ 'status' => true, 'meta' => null, 'data' => null, 'message' => $id.' numaralı domain silindi' ] , 200 );
    }

    /**
     * @param int $id
     * @return JsonResponse
     * Domaini ve ilişkili olduğu tüm veriyi silip domaini tekrar sıraya koyar
     */
    public function addToQueue( int $id ){

        $domain = $this->entityManager->getRepository( Domains::class )->find( $id );

        $tempDomain = $domain->getDomain();
        $tempDropDate = $domain->getDropDate()->format( 'Y-m-d' );

        if ( ! $domain ) {
            return new JsonResponse( [ 'status' => false, 'meta' => null, 'data' => null, 'message' => $id.' numaralı domain bulunamadı' ] , 404 );
        }

        $this->entityManager->remove( $domain );
        $this->entityManager->flush();

        $message = new Worker1Message( [ 'domain' => $tempDomain, 'drop_date' => $tempDropDate ] );
        $this->messageBus->dispatch( $message );

        return new JsonResponse( [ 'status' => true, 'meta' => null, 'data' => null, 'message' => $id.' numaralı domain silinip tekrar sıraya eklendi' ] , 200 );
    }

    /**
     * @param int $id
     * @return JsonResponse
     * Domainin onaylanma durumunu değiştirir
     */
    public function approveToggleDomain( int $id ){

        $domain = $this->entityManager->getRepository( Domains::class )->find( $id );

        if ( ! $domain ) {
            return new JsonResponse( [ 'status' => false, 'meta' => null, 'data' => null, 'message' => $id.' numaralı domain bulunamadı' ] , 404 );
        }

        $domain->setApproved( ! $domain->isApproved() );

        try {
            $this->entityManager->persist( $domain );
            $this->entityManager->flush();
        }
        catch ( \Exception $error ){
            return new JsonResponse( [ 'status' => false, 'meta'=> null, 'data' => null, 'message' => $error->getMessage() ], 401 );
        }
        return new JsonResponse( [ 'status' => true, 'meta'=> null, 'data' => $domain->isApproved(), 'message' => 'Domain Güncellendi' ], 401 );
    }
}